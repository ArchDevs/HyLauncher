package download

import (
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"time"

	"HyLauncher/internal/progress"
)

// Generated by AI. Its working, do not touch

const (
	maxRetries      = 5                // Increased from 3 to 5
	retryDelay      = 3 * time.Second  // Increased from 2s to 3s
	downloadTimeout = 45 * time.Minute // Increased from 30m to 45m
	connectTimeout  = 60 * time.Second // Timeout for initial connection
)

// DownloadWithReporter downloads a file with progress reporting using a Reporter
func DownloadWithReporter(
	dest string,
	url string,
	fileName string,
	reporter *progress.Reporter,
	stage progress.Stage,
	scaler *progress.Scaler,
) error {
	var lastErr error

	for attempt := 1; attempt <= maxRetries; attempt++ {
		if attempt > 1 {
			if scaler != nil {
				scaler.Report(stage, 0, fmt.Sprintf("Retrying download (attempt %d/%d)...", attempt, maxRetries))
			} else if reporter != nil {
				reporter.Report(stage, 0, fmt.Sprintf("Retrying download (attempt %d/%d)...", attempt, maxRetries))
			}
			// Exponential backoff with jitter and cap at 60 seconds
			backoff := retryDelay * time.Duration(1<<uint(attempt-2))
			if backoff > 60*time.Second {
				backoff = 60 * time.Second
			}
			fmt.Printf("Waiting %v before retry...\n", backoff)
			time.Sleep(backoff)
		}

		err := attemptDownloadWithReporter(dest, url, fileName, reporter, stage, scaler)
		if err == nil {
			return nil
		}

		lastErr = err
		fmt.Printf("Download attempt %d failed: %v\n", attempt, err)

		// On Windows, if file is locked or we have permission issues, try to clean up
		if runtime.GOOS == "windows" && attempt < maxRetries {
			time.Sleep(2 * time.Second) // Give Windows time to release handles
		}
	}

	return fmt.Errorf("download failed after %d attempts: %w", maxRetries, lastErr)
}

func attemptDownloadWithReporter(
	dest string,
	url string,
	fileName string,
	reporter *progress.Reporter,
	stage progress.Stage,
	scaler *progress.Scaler,
) error {
	// Add diagnostic logging
	fmt.Printf("Attempting to download from: %s\n", url)

	client := createOptimizedClient()

	tempDest := dest + ".tmp"

	if err := os.MkdirAll(filepath.Dir(dest), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Check if partial file exists
	var resumeFrom int64 = 0
	if stat, err := os.Stat(tempDest); err == nil {
		resumeFrom = stat.Size()
		fmt.Printf("Resuming download from byte %d\n", resumeFrom)
	}

	// Create request with context for timeout control
	ctx, cancel := context.WithTimeout(context.Background(), downloadTimeout)
	defer cancel()

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return err
	}

	req.Header.Set("Accept", "*/*")
	req.Header.Set("Accept-Encoding", "identity")
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("User-Agent", "HyLauncher/1.0")

	if resumeFrom > 0 {
		req.Header.Set("Range", fmt.Sprintf("bytes=%d-", resumeFrom))
	}

	fmt.Println("Connecting to server...")
	resp, err := client.Do(req)
	if err != nil {
		// Provide more detailed error information
		return fmt.Errorf("connection failed (this may be due to firewall/antivirus or network issues): %w", err)
	}
	defer resp.Body.Close()

	fmt.Printf("Connected! Status: %s\n", resp.Status)

	// Handle response status
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusPartialContent {
		// If Range request is not supported, start from beginning
		if resp.StatusCode == http.StatusRequestedRangeNotSatisfiable ||
			(resumeFrom > 0 && resp.StatusCode != http.StatusPartialContent) {
			resumeFrom = 0
			// Retry without Range header
			req.Header.Del("Range")
			resp.Body.Close()
			resp, err = client.Do(req)
			if err != nil {
				return err
			}
			defer resp.Body.Close()
			if resp.StatusCode != http.StatusOK {
				return fmt.Errorf("bad status: %s", resp.Status)
			}
		} else {
			return fmt.Errorf("bad status: %s", resp.Status)
		}
	}

	totalSize := resp.ContentLength
	if resumeFrom > 0 && resp.StatusCode == http.StatusPartialContent {
		totalSize += resumeFrom
	}

	if totalSize <= 0 {
		totalSize = -1
	}

	flag := os.O_CREATE | os.O_WRONLY
	if resumeFrom > 0 && resp.StatusCode == http.StatusPartialContent {
		flag |= os.O_APPEND
	} else {
		flag |= os.O_TRUNC
		resumeFrom = 0
	}

	out, err := os.OpenFile(tempDest, flag, 0644)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer out.Close()

	buffer := make([]byte, 64*1024) // Larger buffer for better performance
	downloaded := resumeFrom
	startTime := time.Now()
	lastUpdate := startTime
	var lastDownloaded int64 = resumeFrom

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		n, err := resp.Body.Read(buffer)
		if n > 0 {
			written, writeErr := out.Write(buffer[:n])
			if writeErr != nil {
				return fmt.Errorf("write error: %w", writeErr)
			}
			if written != n {
				return fmt.Errorf("short write: wrote %d bytes, expected %d", written, n)
			}

			downloaded += int64(n)
			now := time.Now()

			if (reporter != nil || scaler != nil) && now.Sub(lastUpdate) >= 200*time.Millisecond {
				elapsed := now.Sub(lastUpdate).Seconds()
				speed := ""
				if elapsed > 0 {
					recentBytes := float64(downloaded - lastDownloaded)
					speed = formatSpeed(recentBytes / elapsed)
				}

				var prog float64
				if totalSize > 0 {
					prog = float64(downloaded) / float64(totalSize) * 100
				} else {
					prog = 0
				}

				if scaler != nil {
					scaler.ReportDownload(stage, prog, "Downloading...", fileName, speed, downloaded, totalSize)
				} else if reporter != nil {
					reporter.ReportDownload(stage, prog, "Downloading...", fileName, speed, downloaded, totalSize)
				}

				lastUpdate = now
				lastDownloaded = downloaded
			}
		}

		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("read error: %w", err)
		}
	}

	if err := out.Sync(); err != nil {
		return fmt.Errorf("sync error: %w", err)
	}

	// Close file before rename
	if err := out.Close(); err != nil {
		return fmt.Errorf("close error: %w", err)
	}

	// Atomic rename
	if runtime.GOOS == "windows" {
		os.Remove(dest)
	}

	if err := os.Rename(tempDest, dest); err != nil {
		return fmt.Errorf("rename error: %w", err)
	}

	if scaler != nil {
		scaler.ReportDownload(stage, 100, "Download complete", fileName, "", downloaded, totalSize)
	} else if reporter != nil {
		reporter.ReportDownload(stage, 100, "Download complete", fileName, "", downloaded, totalSize)
	}

	return nil
}

func createOptimizedClient() *http.Client {
	// Custom dialer for optimized connections with longer timeouts
	dialer := &net.Dialer{
		Timeout:   60 * time.Second, // Increased from 30s to 60s for slow connections
		KeepAlive: 60 * time.Second,
		// Enable dual stack (IPv4 and IPv6) for better connectivity
		DualStack: true,
	}

	transport := &http.Transport{
		DialContext:           dialer.DialContext,
		MaxIdleConns:          100,
		MaxIdleConnsPerHost:   10,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   20 * time.Second, // Increased from 10s to 20s
		ExpectContinueTimeout: 2 * time.Second,  // Increased from 1s to 2s
		ForceAttemptHTTP2:     true,
		// Disable compression to avoid issues with some CDNs
		DisableCompression: false,
		TLSClientConfig: &tls.Config{
			MinVersion:         tls.VersionTLS12,
			InsecureSkipVerify: false, // Keep secure
		},
		// Proxy settings - respect system proxy
		Proxy: http.ProxyFromEnvironment,
	}

	return &http.Client{
		Timeout:   downloadTimeout,
		Transport: transport,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			if len(via) >= 10 {
				return fmt.Errorf("too many redirects")
			}
			return nil
		},
	}
}

func formatSpeed(bytesPerSec float64) string {
	const unit = 1024
	if bytesPerSec < unit {
		return fmt.Sprintf("%.0f B/s", bytesPerSec)
	}

	div, exp := float64(unit), 0
	for n := bytesPerSec / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}

	return fmt.Sprintf("%.1f %cB/s", bytesPerSec/div, "KMGTPE"[exp])
}
